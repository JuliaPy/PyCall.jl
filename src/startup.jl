# Finding python. This is slightly complicated in order to support using PyCall
# from libjulia. We check if python symbols are present in the current process
# and if so do not use the deps.jl file, getting everything we need from the
# current process instead.

proc_handle = unsafe_load(is_windows() ? cglobal(:jl_exe_handle, Ptr{Void}) : cglobal(:jl_dl_handle, Ptr{Void}))

immutable Dl_info
    dli_fname::Ptr{UInt8}
    dli_fbase::Ptr{Void}
    dli_sname::Ptr{UInt8}
    dli_saddr::Ptr{Void}
end
EnumProcessModules(hProcess, lphModule, cb, lpcbNeeded) =
    ccall(:K32EnumProcessModules, stdcall, Bool,
        (Ptr{Void}, Ptr{Ptr{Void}}, UInt32, Ptr{UInt32}),
        hProcess, lphModule, cb, lpcbNeeded)

symbols_present = false
if is_windows()
    lpcbneeded = Ref{UInt32}()
    proc_handle = ccall(:GetCurrentProcess, stdcall, Ptr{Void}, ())
    handles = Vector{Ptr{Void}}(20)
    if EnumProcessModules(proc_handle, handles, sizeof(handles), lpcbneeded) == 0
        resize!(handles, div(lpcbneeded[],sizeof(Ptr{Void})))
        EnumProcessModules(proc_handle, handles, sizeof(handles), lpcbneeded)
    end
    # Try to find python if it's in the current process
    for handle in handles
        sym = ccall(:GetProcAddress, stdcall, Ptr{Void},
            (Ptr{Void}, Ptr{UInt8}), handle, "Py_GetVersion")
        sym != C_NULL || continue
        symbols_present = true
        global libpy_handle = handle
        break
    end
else
    proc_handle = unsafe_load(cglobal(:jl_dl_handle, Ptr{Void}))
    symbols_present = hassym(proc_handle, :Py_GetVersion)
end

if !symbols_present
    # Python not present. Use deps.jl
    const depfile = joinpath(dirname(@__FILE__), "..", "deps", "deps.jl")
    isfile(depfile) || error("PyCall not properly installed. Please run Pkg.build(\"PyCall\")")
    include(depfile) # generated by Pkg.build("PyCall")
    # Only to be used at top-level - pointer will be invalid after reload
    libpy_handle = Libdl.dlopen(libpython, Libdl.RTLD_LAZY|Libdl.RTLD_DEEPBIND|Libdl.RTLD_GLOBAL)
    # need SetPythonHome to avoid warning, #299
    Py_SetPythonHome(libpy_handle, PYTHONHOME, wPYTHONHOME, pyversion_build)
else
    if is_windows()
        pathbuf = Vector{UInt16}(1024)
        ret = ccall(:GetModuleFileNameW, stdcall, UInt32,
            (Ptr{Void}, Ptr{UInt16}, UInt32),
            libpy_handle, pathbuf, length(pathbuf))
        @assert ret != 0
        libname = String(Base.transcode(UInt8, pathbuf[1:findfirst(pathbuf, 0)-1]))
    else
        libpy_handle = proc_handle
        # Now determine the name of the python library that these symbols are from
        some_address_in_libpython = Libdl.dlsym(libpy_handle, :Py_GetVersion)
        dlinfo = Ref{Dl_info}()
        ccall(:dladdr, Cint, (Ptr{Void}, Ptr{Dl_info}), some_address_in_libpython,
            dlinfo)
        libname = unsafe_string(dlinfo[].dli_fname)
    end
    if (Libdl.dlopen_e(libname) != C_NULL)
        const libpython = libname
    else
        const libpython = nothing
    end
    # If we're not in charge, assume the user is installing necessary python
    # libraries rather than messing with their configuration
    const conda = false
end

const pyversion = convert(VersionNumber, split(Py_GetVersion(libpy_handle))[1])

# PyUnicode_* may actually be a #define for another symbol, so
# we cache the correct dlsym
const PyUnicode_AsUTF8String =
    findsym(libpy_handle, :PyUnicode_AsUTF8String, :PyUnicodeUCS4_AsUTF8String, :PyUnicodeUCS2_AsUTF8String)
const PyUnicode_DecodeUTF8 =
    findsym(libpy_handle, :PyUnicode_DecodeUTF8, :PyUnicodeUCS4_DecodeUTF8, :PyUnicodeUCS2_DecodeUTF8)

# Python 2/3 compatibility: cache symbols for renamed functions
if hassym(libpy_handle, :PyString_FromStringAndSize)
    const PyString_FromStringAndSize = :PyString_FromStringAndSize
    const PyString_AsStringAndSize = :PyString_AsStringAndSize
    const PyString_Size = :PyString_Size
    const PyString_Type = :PyString_Type
else
    const PyString_FromStringAndSize = :PyBytes_FromStringAndSize
    const PyString_AsStringAndSize = :PyBytes_AsStringAndSize
    const PyString_Size = :PyBytes_Size
    const PyString_Type = :PyBytes_Type
end
if hassym(libpy_handle, :PyInt_Type)
    const PyInt_Type = :PyInt_Type
    const PyInt_FromSize_t = :PyInt_FromSize_t
    const PyInt_FromSsize_t = :PyInt_FromSsize_t
    const PyInt_AsSsize_t = :PyInt_AsSsize_t
else
    const PyInt_Type = :PyLong_Type
    const PyInt_FromSize_t = :PyLong_FromSize_t
    const PyInt_FromSsize_t = :PyLong_FromSsize_t
    const PyInt_AsSsize_t = :PyLong_AsSsize_t
end

# hashes changed from long to intptr_t in Python 3.2
const Py_hash_t = pyversion < v"3.2" ? Clong:Int

# whether to use unicode for strings by default, ala Python 3
const pyunicode_literals = pyversion >= v"3.0"

if libpython == nothing
    macro pysym(func)
        :($func)
    end
    macro pyglobal(name)
        :(cglobal($name))
    end
    macro pyglobalobj(name)
        :(cglobal($name, PyObject_struct))
    end
    macro pyglobalobjptr(name)
        :(unsafe_load(cglobal($name, Ptr{PyObject_struct})))
    end
else
    macro pysym(func)
        :(($func, libpython))
    end
    macro pyglobal(name)
        :(cglobal(($name, libpython)))
    end
    macro pyglobalobj(name)
        :(cglobal(($name, libpython), PyObject_struct))
    end
    macro pyglobalobjptr(name)
        :(unsafe_load(cglobal(($name, libpython), Ptr{PyObject_struct})))
    end
end
